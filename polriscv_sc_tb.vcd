$date
	Sat Jun 07 14:33:16 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module poliriscv_sc_tb $end
$scope module riscv $end
$var wire 1 ! clk $end
$var wire 1 " mem2reg $end
$var wire 1 # memwrite $end
$var wire 1 $ rst $end
$var wire 1 % zero $end
$var wire 1 & regwrite $end
$var wire 1 ' pcsrc $end
$var wire 32 ( pc [31:0] $end
$var wire 32 ) instruction [31:0] $end
$var wire 1 * branch $end
$var wire 1 + alusrc $end
$var wire 4 , aluctl [3:0] $end
$var parameter 88 - IFILE $end
$var parameter 32 . datawords $end
$var parameter 32 / instructions $end
$scope module control_unit0 $end
$var wire 1 + alusrc $end
$var wire 1 * branch $end
$var wire 3 0 funct3 [2:0] $end
$var wire 7 1 funct7 [6:0] $end
$var wire 1 " mem2reg $end
$var wire 1 # memwrite $end
$var wire 7 2 opcode [6:0] $end
$var wire 1 ' pcsrc $end
$var wire 1 & regwrite $end
$var wire 1 % zero $end
$var wire 1 3 is_rtype $end
$var wire 1 4 is_lui $end
$var wire 1 5 is_jtype $end
$var wire 1 6 is_jalr $end
$var wire 1 7 is_itype $end
$var wire 1 8 is_branch $end
$var wire 4 9 aluctl [3:0] $end
$var parameter 7 : BRANCH $end
$var parameter 7 ; I_TYPE $end
$var parameter 7 < JALR $end
$var parameter 7 = J_TYPE $end
$var parameter 7 > LUI $end
$var parameter 7 ? R_TYPE $end
$upscope $end
$scope module datapath0 $end
$var wire 4 @ aluctl [3:0] $end
$var wire 1 + alusrc $end
$var wire 1 * branch $end
$var wire 1 ! clk $end
$var wire 1 " mem2reg $end
$var wire 1 # memwrite $end
$var wire 1 ' pcsrc $end
$var wire 1 & regwrite $end
$var wire 1 $ rst $end
$var wire 1 % zero $end
$var wire 32 A ula_out [31:0] $end
$var wire 32 B rd2 [31:0] $end
$var wire 32 C rd1 [31:0] $end
$var wire 32 D pc [31:0] $end
$var wire 32 E next_pc [31:0] $end
$var wire 1 F is_lui $end
$var wire 1 G is_jalr $end
$var wire 32 H instruction [31:0] $end
$var wire 32 I imm [31:0] $end
$var wire 32 J entrada_2_ula [31:0] $end
$var wire 32 K data_mem_out [31:0] $end
$var wire 32 L WriteData [31:0] $end
$var parameter 88 M IFILE $end
$var parameter 32 N W $end
$scope module dm0 $end
$var wire 1 ! clk $end
$var wire 1 O memread $end
$var wire 1 # memwrite $end
$var wire 32 P data_in [31:0] $end
$var wire 32 Q addr [31:0] $end
$var parameter 32 R W $end
$var reg 32 S data_out [31:0] $end
$upscope $end
$scope module ig0 $end
$var wire 7 T opcode [6:0] $end
$var wire 32 U instruction [31:0] $end
$var reg 32 V imm_out [31:0] $end
$upscope $end
$scope module im0 $end
$var wire 1 W CS $end
$var wire 1 X OE $end
$var wire 1 Y regwrite $end
$var wire 32 Z word_addr [31:0] $end
$var wire 32 [ addr [31:0] $end
$var parameter 88 \ IFILE $end
$var parameter 32 ] W $end
$var reg 32 ^ out [31:0] $end
$var integer 32 _ i [31:0] $end
$upscope $end
$scope module jmp0 $end
$var wire 32 ` imm [31:0] $end
$var wire 1 G is_jalr $end
$var wire 1 ' pcsrc $end
$var wire 32 a rs1_mais_imm [31:0] $end
$var wire 32 b rd1 [31:0] $end
$var wire 32 c pc_mais_imm [31:0] $end
$var wire 32 d pc_mais_4 [31:0] $end
$var wire 32 e pc [31:0] $end
$var wire 32 f next_pc [31:0] $end
$var parameter 32 g W $end
$upscope $end
$scope module pc0 $end
$var wire 1 ! clk $end
$var wire 32 h next_pc [31:0] $end
$var wire 1 $ rst $end
$var parameter 32 i W $end
$var reg 32 j pc [31:0] $end
$upscope $end
$scope module rf0 $end
$var wire 5 k Read1 [4:0] $end
$var wire 5 l Read2 [4:0] $end
$var wire 1 & RegWrite $end
$var wire 32 m WriteData [31:0] $end
$var wire 5 n WriteReg [4:0] $end
$var wire 1 ! clk $end
$var wire 32 o Data2 [31:0] $end
$var wire 32 p Data1 [31:0] $end
$var parameter 32 q W $end
$var integer 32 r i [31:0] $end
$upscope $end
$scope module ula0 $end
$var wire 32 s A [31:0] $end
$var wire 4 t ALUctl [3:0] $end
$var wire 32 u B [31:0] $end
$var wire 1 $ rst $end
$var wire 1 % zero $end
$var wire 32 v ALUout [31:0] $end
$var parameter 32 w W $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 w
b100000 q
b100000 i
b100000 g
b100000 ]
b111001001101111011011010101111101101000011001010111100000101110011011010110010101101101 \
b100000 R
b100000 N
b111001001101111011011010101111101101000011001010111100000101110011011010110010101101101 M
b110011 ?
b110111 >
b1101111 =
b1100111 <
b10011 ;
b1100011 :
b100000000 /
b10000000000 .
b111001001101111011011010101111101101000011001010111100000101110011011010110010101101101 -
$end
#0
$dumpvars
bx v
bx u
b0x10 t
bx s
b100000 r
bx p
bx o
bx n
bx m
bx l
bx k
b0 j
bx h
bx f
b0 e
b100 d
bx c
bx b
bx a
bx `
b10000000000 _
bx ^
b0 [
b0 Z
0Y
1X
1W
bx V
bx U
bx T
bx S
bx Q
bx P
1O
bx L
bx K
bx J
bx I
bx H
xG
xF
bx E
b0 D
bx C
bx B
bx A
b0x10 @
b0x10 9
x8
x7
x6
x5
x4
x3
bx 2
bx 1
bx 0
b0x10 ,
x+
x*
bx )
b0 (
x'
x&
x%
x$
0#
0"
0!
$end
#1000
1$
#2000
0$
#5000
0%
b110 L
b110 m
b110 A
b110 Q
b110 v
1&
0'
b110 J
b110 u
1+
b0 B
b0 P
b0 o
b110 a
b0 C
b0 b
b0 p
b0 s
b10 ,
b10 9
b10 @
b10 t
b10011 T
b1010 n
b110 l
b0 k
0F
0G
b0 1
b0 0
03
17
0*
08
05
06
04
b10011 2
b110 I
b110 V
b110 `
b0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Z
b11000000000010100010011 )
b11000000000010100010011 H
b11000000000010100010011 U
b11000000000010100010011 ^
bx d
bx (
bx D
bx [
bx e
bx j
1!
#10000
0!
#12000
